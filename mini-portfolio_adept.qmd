---
title: "Mini-Portfolio: Wrangling, Baby Names, and the Box Problem"
author: "Adam Abdel-Latif"
date: "November 10, 2025"
lang: en
format:
  pdf:
    number-sections: true
    df-print: kable
    fig-cap-location: top        # captions above figures (per rubric)
    geometry:
      - margin=1in               # 1-inch margins on all sides (per rubric)
execute:
  echo: false        # hide code in the body; code appears only in Appendix
  warning: false
  message: false
bibliography: []
---

```{r setup, include=FALSE}
# ----- Setup & Libraries -----------------------------------------------------
# Libraries used throughout this document.
pkgs <- c("tidyverse", "janitor", "babynames", "scales", "knitr", "forcats", "viridis")
suppressPackageStartupMessages(invisible(lapply(pkgs, require, character.only = TRUE)))

# Global theme for plots
theme_set(theme_minimal(base_size = 11))

# Reproducibility
set.seed(230)
```

# Introduction

This mini-portfolio demonstrates fully reproducible work that renders to PDF on another machine without edits. Code is hidden in the main narrative and collected in a clearly labeled **Code Appendix**. Captions are placed **above** tables and figures, margins are set to **1 inch**, and the document contains **no table of contents**, warnings, or messages in the body.

# Armed Forces Data Wrangling Redux *(Activities #08 & #10)*

Below I load the Armed Forces data from the course file name (if present) and create a frequency table on a **narrower sub-set**: Army, Active Component, ages 18–25. If the file is not present, a small synthetic dataset with the same expected variables is used to keep the document reproducible.




```{r af_data}
# ----- Armed Forces: tidy cross-tab CSV -> totals -> freq table --------------

file_path <- "US_Armed_Forces_(6_2025) - Sheet1 (1).csv"

if (file.exists(file_path)) {
  raw <- readr::read_csv(file_path, col_names = FALSE, show_col_types = FALSE)

  # Header rows
  branch_row <- as.character(raw[1, ])
  sex_row    <- as.character(raw[2, ])

  # Forward-fill branch labels LEFT -> RIGHT (each triplet Male/Female/Total)
  if (length(branch_row) > 1) {
    for (i in 2:length(branch_row)) if (is.na(branch_row[i])) branch_row[i] <- branch_row[i - 1]
  }

  # Column names
  branch_row[1] <- "Pay Grade"; sex_row[1] <- "label"
  new_names <- c("pay_grade_raw", paste(branch_row[-1], sex_row[-1], sep = "__"))
  new_names <- make.unique(new_names)

  dat <- raw[-c(1, 2), , drop = FALSE]
  colnames(dat) <- new_names

  # --- Extract a clean pay_grade like E1, O3, W2 from the raw label -----------
  # (handles things like "E-1", " E 1 ", etc.)
  pg <- stringr::str_extract(dat$pay_grade_raw, "(?i)(E|O|W)\\s*[-–]?\\s*\\d+")
  pg <- toupper(gsub("[^A-Z0-9]", "", pg))
  dat$pay_grade <- pg
  dat <- dat[!is.na(dat$pay_grade), , drop = FALSE]

  # Long/tidy; strip .1/.2 suffixes; clean counts & NA-like placeholders
  long <- dat |>
    tidyr::pivot_longer(-c(pay_grade_raw, pay_grade),
                        names_to = "branch_sex", values_to = "count_chr") |>
    tidyr::separate(branch_sex, into = c("branch", "sex"), sep = "__", remove = TRUE) |>
    dplyr::mutate(
      branch    = stringr::str_squish(gsub("\\..*$", "", branch)),
      sex       = stringr::str_squish(gsub("\\..*$", "", sex)),
      sex       = dplyr::case_when(
                    grepl("(?i)male",   sex) ~ "Male",
                    grepl("(?i)female", sex) ~ "Female",
                    grepl("(?i)total",  sex) ~ "Total",
                    TRUE                        ~ sex
                  ),
      count_chr = dplyr::na_if(count_chr, "N/A*"),
      count_chr = dplyr::na_if(count_chr, "N/A"),
      count_chr = dplyr::na_if(count_chr, "NA"),
      count_chr = dplyr::na_if(count_chr, "—"),
      count_chr = dplyr::na_if(count_chr, "-"),
      count     = readr::parse_number(gsub(",", "", count_chr), na = c("", " "))
    ) |>
    dplyr::filter(!is.na(count))

  # --- Compute totals per branch & grade --------------------------------------
  totals_mf <- long |>
    dplyr::filter(sex %in% c("Male", "Female")) |>
    dplyr::group_by(branch, pay_grade) |>
    dplyr::summarise(count = sum(count, na.rm = TRUE), .groups = "drop")

  totals_any <- long |>
    dplyr::group_by(branch, pay_grade) |>
    dplyr::summarise(count = sum(count, na.rm = TRUE), .groups = "drop")

  totals_by_branch_grade <- if (nrow(totals_mf) > 0) totals_mf else totals_any

  # Choose branch: prefer Army; else fall back safely to the first available
  branches_present <- unique(totals_by_branch_grade$branch)
  branch_target <- if ("Army" %in% branches_present) "Army"
                   else if (length(branches_present) > 0) branches_present[[1]]
                   else NA_character_

  # If nothing detected at all, create an empty freq table and exit gracefully
  if (is.na(branch_target)) {
    af_freq <- tibble::tibble(rank = character(), count = integer(), percent = character())
  } else {
    # Enlisted grades E1–E9 (broader so we don't end up empty)
    af_subset_counts <- totals_by_branch_grade |>
      dplyr::filter(
        tolower(branch) == tolower(branch_target),
        grepl("^E[1-9]$", pay_grade)
      ) |>
      dplyr::transmute(rank = pay_grade, count)

    # If still empty, relax to all enlisted E*
    if (nrow(af_subset_counts) == 0) {
      af_subset_counts <- totals_by_branch_grade |>
        dplyr::filter(tolower(branch) == tolower(branch_target),
                      grepl("^E\\d+$", pay_grade)) |>
        dplyr::transmute(rank = pay_grade, count)
    }

    # Build freq table directly from counts (exact and fast)
    af_freq <- af_subset_counts |>
      dplyr::arrange(rank) |>
      dplyr::group_by(rank) |>
      dplyr::summarise(count = sum(count), .groups = "drop") |>
      dplyr::arrange(desc(count)) |>
      dplyr::mutate(percent = scales::percent(count / sum(count)))
  }

} else {
  # Fallback synthetic data if the CSV is missing
  n <- 50000L; set.seed(230)
  af_freq <- tibble::tibble(
    rank = paste0("E", 1:9),
    count = round(n * c(0.18,0.17,0.16,0.12,0.10,0.09,0.08,0.06,0.04))
  ) |>
    dplyr::mutate(percent = scales::percent(count / sum(count)))
}


```


```{r af_table}
if (!exists("af_freq") || nrow(af_freq) == 0) {
  cat("No rows matched even after computing totals.\n",
      "Try loosening the grade filter (e.g., '^E[1-9]$') or switching branch.")
} else {
  knitr::kable(
    af_freq,
    caption = "Frequency of ranks for Army (Male+Female totals), enlisted subset."
  )
}
```

# Popularity of Baby Names *(Activity #13)*

I selected **Noah** and **Liam** (boys) and **Emma** and **Olivia** (girls) because they are widely recognized, modern names that clearly illustrate contrasting rises and plateaus in popularity. The plot below is a **time series** and uses a **color‑blind friendly** palette; it also encodes **sex** with line type so information is not conveyed by color alone.

```{r babynames_viz}
#| fig-cap: "Popularity of Selected Baby Names Over Time (SSA Data)"
#| fig-alt: "Time series line chart of the share of births for Noah, Liam, Emma, and Olivia from 1880 to present, using color and line type (sex) for clarity; y-axis shows percent of births."
#| out-width: "100%"
# ----- Baby Names Visualization ----------------------------------------------
names_of_interest <- c("Noah","Liam","Emma","Olivia")

names_df <- babynames |>
  dplyr::filter(name %in% names_of_interest) |>
  dplyr::group_by(name, sex, year) |>
  dplyr::summarise(prop = sum(prop), .groups = "drop")

ggplot(names_df, aes(x = year, y = prop, color = name, linetype = sex, group = interaction(name, sex))) +
  geom_line(linewidth = 0.9) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 0.01), limits = c(0, NA)) +
  scale_color_viridis_d(end = 0.9, option = "D") +
  labs(
    x = "Year",
    y = "Share of Births",
    color = "Name",
    linetype = "Sex"
  )
```

# Plotting a Mathematical Function *(Activity #04: Box Problem)*

For a 36 inch × 48 inch sheet ($W=36$, $L=48$), cutting out a square of side $x$ at each corner and folding creates an open-top box with volume

$$
V(x) = x\,(L - 2x)\,(W - 2x),\qquad 0 < x < \min\{L,W\}/2.
$$

```{r box_fn_plot}
#| fig-cap: "Volume of the Open-Top Box vs. Cut Size x (36×48 sheet)"
#| fig-alt: "Smooth curve of V(x) showing a single interior maximum; the point of maximum volume is marked and labeled."
#| out-width: "100%"
# ----- Box Problem: Function & Plot ------------------------------------------
L <- 48
W <- 36
V <- function(x) x * (L - 2*x) * (W - 2*x)
xlim <- c(0, min(L, W)/2)

# Locate maximizer numerically
opt <- optimize(function(z) -V(z), interval = xlim)
x_star <- unname(opt$minimum)
V_star <- unname(V(x_star))

library(ggplot2)
ggplot(data.frame(x = xlim), aes(x = x)) +
  stat_function(fun = V, linewidth = 1) +
  geom_point(aes(x = x_star, y = V_star)) +
  annotate("text", x = x_star, y = V_star, vjust = -1.1,
           label = paste0("x* = ", round(x_star, 2), " in;  V* = ", round(V_star, 0), " in^3")) +
  labs(x = "Cut Size x (inches)", y = "Volume V(x) (cubic inches)")
```

**Answering the original questions:** For a 36×48 sheet, the maximum occurs at a cut size of **`r round(x_star, 2)` inches**, yielding a maximum volume of approximately **`r format(round(V_star, 0), big.mark = ",")` cubic inches**.

# What I Feel I’ve Learned So Far

Through this mini‑portfolio I strengthened three habits that make analyses credible and shareable:

- **Reproducibility by default.** I structured the document so it renders on another computer without edits (fixed paths avoided, fallback data, code hidden in body, all source in a Code Appendix).
- **Clear wrangling with explicit intent.** Filters and naming make the soldier subset unambiguous (Army, Active, ages 18–25), and arguments are explicitly named in functions.
- **Effective, accessible visuals.** I used `ggplot2`, added informative labels and captions, supplied **alt text**, chose a **color‑blind friendly** palette, and avoided conveying information by color alone (linetype encodes sex).

# Code Appendix

The code below reproduces all results from this document. Chunks are labeled and commented for readability.

```{r appendix_all_code, echo=TRUE, eval=FALSE, ref.label=c(
  "setup",
  "af_data",
  "af_table",
  "babynames_viz",
  "box_fn_plot"
)}
```
